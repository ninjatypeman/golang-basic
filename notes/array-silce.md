# Go 语言中的 Array 和 Slice

Go 语言的 Array（数组）和 Slice（切片）都是用于存储相同类型元素的集合，但它们在使用和行为上有重要区别。

## 数组 (Array)

**数组**是固定长度的、同类型元素的序列，其长度是类型的一部分。

### 特点：
1. **固定长度**：声明时必须指定长度，之后不能改变
2. **值类型**：赋值或传递数组会创建副本
3. **内存分配**：在栈上分配（小数组）或静态存储区

### 声明和初始化：
```go
// 声明一个包含5个int的数组，初始化为零值
var a [5]int

// 声明并初始化
b := [3]int{1, 2, 3}

// 编译器推断长度
c := [...]int{4, 5, 6, 7}

// 指定索引初始化
d := [5]int{1: 10, 3: 30}
```

### 使用：
```go
fmt.Println(a[0]) // 访问元素
a[2] = 7         // 修改元素
len(a)           // 获取长度
```

## 切片 (Slice)

**切片**是对数组的抽象，提供了更灵活、更强大的序列接口。它本质上是一个指向底层数组的引用类型。

### 特点：
1. **动态大小**：可以按需增长和缩减
2. **引用类型**：赋值或传递切片不创建副本
3. **三部分组成**：指向数组的指针、长度(len)和容量(cap)
4. **底层数组**：切片总是基于某个数组

### 声明和初始化：
```go
// 从数组创建
arr := [5]int{1, 2, 3, 4, 5}
s1 := arr[1:4] // 包含元素2,3,4

// 直接创建
s2 := []int{1, 2, 3} // 注意没有指定长度

// 使用make创建
s3 := make([]int, 3, 5) // 长度为3，容量为5
```

### 常用操作：
```go
s := []int{1, 2, 3}
s = append(s, 4)     // 追加元素，可能需要扩容
len(s)               // 获取长度
cap(s)               // 获取容量
copy(dest, src)      // 复制切片
s = s[:0]            // 清空切片（保留底层数组）
```

## 主要区别

| 特性            | 数组 (Array)               | 切片 (Slice)                |
|---------------|---------------------------|----------------------------|
| 大小           | 固定                      | 动态可变                    |
| 类型           | 例如 [5]int               | 例如 []int                 |
| 内存分配        | 值类型，完整复制           | 引用类型，共享底层数组        |
| 长度           | 编译时确定                | 运行时可变                  |
| 使用频率        | 较少                      | 更常用                      |
| 初始化语法      | [n]T{...}                | []T{...} 或 make([]T, len)|

## 使用建议

1. **多数情况下使用切片**：它们更灵活，是Go中最常用的序列类型
2. **性能考虑**：如果需要固定大小且知道确切的尺寸，可以使用数组
3. **注意切片扩容**：append操作可能导致底层数组重新分配
4. **切片共享问题**：多个切片可能共享同一底层数组，修改时需谨慎

理解数组和切片的区别对于编写高效、正确的Go代码至关重要。